#!/usr/bin/env python3
"""Generate a documentation index and vendor summaries."""
from __future__ import annotations

import argparse
from pathlib import Path
import json

ROOT = Path(__file__).resolve().parents[1]


def load_apps_data(root: Path = ROOT) -> dict[str, dict]:
    """Return apps.json content if available."""
    apps_file = root / "apps.json"
    if apps_file.is_file():
        try:
            return json.loads(apps_file.read_text())
        except Exception:
            return {}
    return {}


def match_app_info(vendor_name: str, apps: dict[str, dict]) -> tuple[str, dict]:
    """Return (slug, info) matching the vendor directory name."""
    for slug, info in apps.items():
        ref = info.get("branch") or info.get("tag") or ""
        sanitized = ref.replace("/", "_") if ref else ""
        expected = slug + (f"-{sanitized}" if sanitized else "")
        if expected == vendor_name:
            return slug, info
    return vendor_name, apps.get(vendor_name, {})


def summarize_vendor(path: Path, apps: dict[str, dict]) -> str:
    """Return summary text for a vendor directory."""
    vendor_name = path.name
    slug, info = match_app_info(vendor_name, apps)
    dirs = [p.name for p in path.iterdir() if p.is_dir()]
    lines = [f"# {vendor_name}", "", f"Overview of **{vendor_name}**."]
    if dirs:
        repo = info.get("repo")
        ref = info.get("commit") or info.get("branch") or info.get("tag") or "main"
        lines.append("\nNotable directories:")
        for d in dirs[:5]:
            if repo:
                label = d
                if info.get("commit"):
                    label = f"{d} @ {info['commit'][:7]}"
                url = f"{repo.rstrip('/')}/tree/{ref}/{d}"
                lines.append(f"- [{label}]({url})")
            else:
                rel = f"../../vendor/{vendor_name}/{d}/"
                lines.append(f"- [{d}]({rel})")
    lines.append("\n*(generated by scripts/generate_index.py)*")
    return "\n".join(lines) + "\n"

def generate_vendor_summaries(root: Path = ROOT) -> list[str]:
    instructions = root / "instructions"
    summary_dir = instructions / "vendors"
    vendors_dir = root / "vendor"
    summary_dir.mkdir(parents=True, exist_ok=True)
    apps = load_apps_data(root)
    vendor_links: list[str] = []
    if not vendors_dir.is_dir():
        return vendor_links
    for vendor in sorted(p for p in vendors_dir.iterdir() if p.is_dir()):
        summary = summarize_vendor(vendor, apps)
        (summary_dir / f"{vendor.name}.md").write_text(summary)
        vendor_links.append(f"- [{vendor.name}](vendors/{vendor.name}.md)")
    return vendor_links


def extract_tags(root: Path = ROOT) -> list[str]:
    project_file = root / "PROJECT.md"
    if not project_file.exists():
        return []
    lines = project_file.read_text().splitlines()
    tags: list[str] = []
    for i, line in enumerate(lines):
        if line.lower().startswith("## tags"):
            if i + 1 < len(lines):
                tags_line = lines[i + 1]
                tags = [t.lstrip("#").strip() for t in tags_line.replace(",", " ").split() if t.strip()]
            break
    return tags


def map_tags_to_vendors(tags: list[str], root: Path = ROOT) -> dict[str, list[str]]:
    instructions = root / "instructions"
    summary_dir = instructions / "vendors"
    mapping = {tag: [] for tag in tags}
    for summary_file in summary_dir.glob("*.md"):
        content = summary_file.read_text().lower()
        slug = summary_file.stem
        link = f"- [{slug}](vendors/{summary_file.name})"
        for tag in tags:
            tag_lower = tag.lower()
            if (
                tag_lower in slug.lower()
                or tag_lower in content
                or (tag_lower == "frappe" and slug.lower().startswith("bench"))
            ):
                mapping[tag].append(link)
    return mapping


def parse_prompts(root: Path = ROOT) -> dict[str, list[str]]:
    """Parse tagged prompt lines from projects.md or PROJECT.md."""
    for name in ("projects.md", "PROJECT.md"):
        p = root / name
        if p.exists():
            prompts_file = p
            break
    else:
        return {}

    mapping: dict[str, list[str]] = {}
    for line in prompts_file.read_text().splitlines():
        line = line.strip()
        if not line or not line.startswith("["):
            continue
        end = line.find("]")
        if end == -1:
            continue
        tag_part = line[1:end]
        prompt = line[end + 1 :].strip()
        tags = [t.strip() for t in tag_part.split(",") if t.strip()]
        for tag in tags:
            mapping.setdefault(tag, []).append(f"- {prompt}")
    return mapping


def write_index(
    vendor_links: list[str],
    tags: list[str],
    tag_map: dict[str, list[str]],
    root: Path = ROOT,
    tasks: dict[str, list[str]] | None = None,
) -> None:
    instructions = root / "instructions"
    index_file = instructions / "_INDEX.md"
    lines = ["# Instructions Index", "", "## Vendor Summaries", ""]
    lines.extend(vendor_links)
    if tags:
        lines.extend(["", "## Tags", ""])
        for tag in tags:
            lines.append(f"### {tag}")
            entries = tag_map.get(tag, [])
            if entries:
                lines.extend(entries)
            lines.append("")
    if tasks:
        lines.extend(["", "## Tasks", ""])
        for tag in sorted(tasks):
            lines.append(f"### {tag}")
            lines.extend(tasks[tag])
            lines.append("")

    index_file.write_text("\n".join(lines).rstrip() + "\n")


def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description="Generate documentation index")
    parser.parse_args(argv)
    tags = extract_tags()
    vendor_links = generate_vendor_summaries()
    tag_map = map_tags_to_vendors(tags)
    tasks = parse_prompts()
    write_index(vendor_links, tags, tag_map, tasks=tasks)


if __name__ == "__main__":
    main()
